/**
 * \file        main.c
 * \brief       This proyect implements an digital signal generator. 
 * \details     In this practice, we will develop a Digital Signal Generator (DSG) device. 
 * The DSG device generates 4 different waveforms: sine, triangular, sawtooth, and square. 
 * The user can select the type of waveform generated by the DSG using a push button. 
 * Each time the button is pressed, the system switches from one waveform to the next sequentially. 
 * The amplitude, DC level (offset), and signal frequency are entered using a 4x4 matrix keypad. 
 * To enter the amplitude, the user will press the A key followed by the desired voltage value in 
 * millivolts and the D key to finalize. Similarly, to enter the DC level, the user will press 
 * the B key followed by the desired DC voltage value in millivolts and the D key to finalize. 
 * Finally, to enter the frequency, the user must press the C key followed by the frequency 
 * value in Hertz and the D key to finalize. The current values of Amplitude, DC Level, and 
 * Frequency along with the current waveform will be printed every second via the serial or USB 
 * interface to a terminal tool. 
 * 
 * The Amplitude should be adjustable between 100mV and 2500mV, the DC Level between 50mV and 1250mV. 
 * The frequency should be adjustable between 1 Hz and 12000000 Hz. 
 * Therefore, the max range for the value of the signal is: -2450mV to 3750mV.
 * 
 * By default, the DSG device starts generating a sinusoidal signal with an amplitude of 1000 mV, 
 * DC Level of 500mV, and frequency of 10Hz. The generated signal and its characteristics 
 * should be able to be verified by a measuring instrument, multimeter, or oscilloscope.
 * 
 * TESTING: 2000mV, 500mV, 100Hz
 * 
 * \author      MST_CDA
 * \version     0.0.1
 * \date        05/10/2023
 * \copyright   Unlicensed
 * 
 */

#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include "pico/stdlib.h"
#include "hardware/timer.h"
#include "pico/cyw43_arch.h"
#include "hardware/gpio.h"

#include "time_base.h"
#include "keypad_polling.h"
#include "gpio_led.h"
#include "gpio_button.h"
#include "signal_generator.h"
#include "dac.h"

static inline bool checkNumber(uint8_t number){
    return (number >= 0 && number <= 9);
}

static inline bool checkLetter(uint8_t letter){
    return (letter >= 0x0A && letter <= 0x0C);
}

static inline bool checkFreq(uint32_t freq){
    return (freq >= 1 && freq <= 12000000);
}

static inline bool checkAmp(uint32_t amp){
    return (amp >= 100 && amp <= 2500);
}

static inline bool checkOffset(uint32_t offset){
    return (offset >= 50 && offset <= 1250);
}


int main() {
    
    stdio_init_all();
    // sleep_ms(5000);
    printf("Hola!!!");

    // Initialize signal generator
    uint8_t in_param_state = 0x00; // 0: Nothing, 1: Entering amp (A), 2: Entering offset (B), 3: Entering freq (C)
    uint32_t param = 0; // This variable will store the value of any parameter that is being entered
    uint8_t key_cont = 0;
    signal_t my_signal;
    signal_gen_init(&my_signal,1,1000,500,true);

    // Initialize DAC
    dac_t my_dac;
    dac_init(&my_dac, 10, true);
    signal_calculate_next_value(&my_signal);

    // Initialize LED
    uint8_t my_led = 18;
    led_init(my_led);
    cyw43_arch_init();

    // Initialize keypad and button
    key_pad_t my_keypad;
    kp_init(&my_keypad,2,6,100000,true);

    gpio_button_t my_button;
    button_init(&my_button, 0, 100000, true);

    // Initialize Printing
    time_base_t tb_print;
    tb_init(&tb_print,1000000,true);
    

    while(1){
        // Process keypad
        uint32_t cols = gpio_get_all() & (0x0000003C0); // 0000 0100 0000
        if(cols && !my_keypad.KEY.dbnc){
            tb_disable(&my_keypad.tb_seq);
            kp_capture(&my_keypad,cols);
            tb_update(&my_keypad.tb_dbnce);
            tb_enable(&my_keypad.tb_dbnce);
            kp_set_zflag(&my_keypad);
            my_keypad.KEY.dbnc = 1;
        }
        if(tb_check(&my_keypad.tb_seq)){
            tb_next(&my_keypad.tb_seq);
            kp_gen_seq(&my_keypad);
        }
        if(tb_check(&my_keypad.tb_dbnce)){
            tb_next(&my_keypad.tb_dbnce);
            if(kp_is_2nd_zero(&my_keypad)){
                if(!cols){
                    // This able to generate seq only when a button is not pressed
                    tb_update(&my_keypad.tb_seq); // It could happens that a button was pressed for a long time
                    tb_enable(&my_keypad.tb_seq);
                    tb_disable(&my_keypad.tb_dbnce);
                    my_keypad.KEY.dbnc = 0;
                }
                else
                    kp_clr_zflag(&my_keypad);
            }
            else{
                if(!cols)
                    kp_set_zflag(&my_keypad);
            }
        }
        // Process button
        bool button = gpio_get(my_button.KEY.gpio_num);
        if(button && !my_button.KEY.dbnc){
            my_button.KEY.nkey = true; // This is a flag that indicates that a key was pressed
            tb_update(&my_button.tb_dbnce); 
            tb_enable(&my_button.tb_dbnce);
            button_set_zflag(&my_button);
            my_button.KEY.dbnc = 1;
        }
        if(tb_check(&my_button.tb_dbnce)){
            tb_next(&my_button.tb_dbnce);
            if(button_is_2nd_zero(&my_button)){
                if(!button){
                    // printf("Button pressed\n");
                    signal_set_state(&my_signal, (my_signal.STATE.ss + 1)%4);
                    signal_calculate_next_value(&my_signal);
                    tb_disable(&my_button.tb_dbnce);
                    my_button.KEY.dbnc = 0;
                }
                else
                    button_clr_zflag(&my_button);
            }
            else{
                if(!button)
                    button_set_zflag(&my_button);
            }
        }
        // Process signal
        if (tb_check(&my_signal.tb_gen)){
            tb_next(&my_signal.tb_gen);
            dac_calculate(&my_dac,my_signal.arrayV[my_signal.cnt]);
            my_signal.cnt = (my_signal.cnt + 1) % SAMPLE;
        }

        // Process printing
        if(tb_check(&tb_print)){
            tb_next(&tb_print);
            switch (my_signal.STATE.ss){
                case 0:
                    printf("Sinusoidal: ");
                    break;
                case 1:
                    printf("Triangular: ");
                    break;
                case 2:
                    printf("Saw tooth: ");
                    break;
                case 3:
                    printf("Square: ");
                    break;
            }
            printf("Amp: %d, Offset: %d, Freq: %d\n", my_signal.amp, my_signal.offset, my_signal.freq);
        }

        // Process entering parameters
        if(my_keypad.KEY.nkey && !my_keypad.KEY.dbnc){
            
            // To accept a number, in_param_state must be different of 0
            if(checkNumber(my_keypad.KEY.dkey) && in_param_state){
                param = (!key_cont)? my_keypad.KEY.dkey : param*10 + my_keypad.KEY.dkey;
                key_cont++;
            }
            // To accept a letter different of 0x0D, in_param_state must be 0
            else if(checkLetter(my_keypad.KEY.dkey) && !in_param_state){
                cyw43_arch_gpio_put(CYW43_WL_GPIO_LED_PIN, 1);
                // led_on(my_led);
                switch (my_keypad.KEY.dkey)
                {
                case 0x0A:
                    in_param_state = 1;
                    break;
                case 0x0B:
                    in_param_state = 2;
                    break;
                case 0x0C:
                    in_param_state = 3;
                    break;
                default:
                    printf("Invalid letter\n");
                    break;
                }
            }
            // To accept a 0x0D, in_param_state must be different of 0
            else if(my_keypad.KEY.dkey == 0x0D && in_param_state){
                cyw43_arch_gpio_put(CYW43_WL_GPIO_LED_PIN, 0);
                // led_off(my_led);
                switch (in_param_state)
                {
                case 1:
                    if(checkAmp(param)){
                        signal_set_amp(&my_signal,param);
                    }
                    break;
                case 2:
                    if(checkOffset(param)){
                        signal_set_offset(&my_signal,param);
                    }
                    break;
                case 3:
                    if(checkFreq(param)){
                        signal_set_freq(&my_signal,param);
                    }
                    break;
                default:
                    printf("Invalid state\n");
                    break;
                }
                signal_calculate_next_value(&my_signal);
                in_param_state = 0;
                param = 0;
                key_cont = 0;
            }
            my_keypad.KEY.nkey = 0;
        }
    }

    return 1;
}