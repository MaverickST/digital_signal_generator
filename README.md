# Digital Signal Generator (DSG)

## Overview

This project implements a Digital Signal Generator (DSG) device capable of generating four different waveforms: sine, triangular, sawtooth, and square. The user can select the type of waveform generated by the DSG using a push button. Additionally, the device allows the user to input parameters such as amplitude, DC level, and signal frequency using a 4x4 matrix keypad. The current values of amplitude, DC level, frequency, and waveform are displayed every second via the serial or USB interface to a terminal tool.

## Features

- Generates four different waveforms: sine, triangular, sawtooth, and square.
- User-selectable waveform using a push button.
- Input parameters via a 4x4 matrix keypad:
  - Amplitude (adjustable between 100mV and 2500mV)
  - DC level (adjustable between 50mV and 1250mV)
  - Frequency (adjustable between 1 Hz and 12,000,000 Hz)
- Default settings:
  - Sine waveform
  - Amplitude: 1000 mV
  - DC Level: 500 mV
  - Frequency: 10 Hz
- Signal range: -2450mV to 3750mV

## Implementation

This project was developed using a Raspberry Pi Pico microcontroller. Three different programming paradigms for embedded systems were utilized:

1. **Polling**: In this implementation, the microcontroller continuously polls the status of input devices (e.g., push button, keypad) to determine user input and generate the appropriate waveform.

2. **Interrupt-driven**: In this implementation, the microcontroller utilizes interrupts to handle user input and waveform generation. Interrupts are triggered by events such as button presses or keypad input, allowing for more efficient use of processor resources.

3. **Hybrid (Polling + Interrupts)**: This implementation combines both polling and interrupts for handling user input and waveform generation. Polling is used for continuous monitoring of input devices, while interrupts are employed to handle time-sensitive events or high-priority tasks.

## Usage

1. Connect the device to a power source.
2. Select the desired waveform by pressing the push button.
3. Enter the parameters using the keypad: A (Amplitud), B (Offset), C (Frequency).
4. Press the 'D' key to finalize each parameter entry.
5. Monitor the generated signal and its characteristics via the serial or USB interface.

## Verification

The generated signal and its characteristics should be verifiable using a measuring instrument such as a multimeter or oscilloscope.

## Maximum frequencies
This will consist of finding out the maximum frequency that each programming flow can generate.
When the signal is generated, then a oscilloscope is used to measure the frequency of the signal.

For testing purposes, the following parameters were used:
- Amplitude: 1000mV
- DC Level: 500mV

The next table sumarizes the testing data.

<table>
  <thead>
    <tr>
      <th scope="col">SAMPLES </th>
      <th scope="col">MicroPython</th>
      <th scope="col">Arduino</th>
	  <th scope="col">Polling in C</th>
	  <th scope="col">IRQ in C</th>
	  <th scope="col">Polling + IRQ in C</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th scope="row">16</th>
      <td>94Hz</td>
      <td>2kHz</td>
	  <td>15kHz</td>
	  <td>17kHz</td>
	  <td>12.5kHz</td>
    </tr>
    <tr>
	<th scope="row">70</th>
      <td>21Hz</td>
	  <td>450Hz</td>
	  <td>3.3kHz</td>
	  <td>3.7kHz</td>
	  <td>2.4kHz</td>
    </tr>
  </tbody>
</table>

> **_NOTE:_** SAMPLES = number of point per signal period


## Memory Usage

To obtain the memory usage of the C codes were used the next lines in the CMakeLists.txt file:
```cmake
SET(GCC_EXE_LINKER_FLAGS    "-Wl,--print-memory-usage")
SET(CMAKE_EXE_LINKER_FLAGS  "${CMAKE_EXE_LINKER_FLAGS} ${GCC_EXE_LINKER_FLAGS}")
```

### Polling in C
<table>
  <thead>
    <tr>
      <th scope="col">Memory Region </th>
      <th scope="col">Used Size</th>
      <th scope="col">Region Size</th>
	  <th scope="col">%age Used</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th scope="row">FLASH:</th>
      <td>286288 B</td>
      <td>2 MB</td>
	  <td>13.65%</td>
    </tr>
    <tr>
	<th scope="row">RAM:</th>
      <td>9692 B</td>
	  <td>256 KB</td>
	  <td>3.70%</td>
    </tr>
	<tr>
	<th scope="row">SCRATCH_X:</th>
      <td>0 GB</td>
	  <td>4 KB</td>
	  <td>0.00%</td>
    </tr>
	<tr>
	<th scope="row">SCRATCH_Y:</th>
      <td>0 GB</td>
	  <td>4 KB</td>
	  <td>0.00%</td>
    </tr>
  </tbody>
</table>

### IRQ in C
<table>
  <thead>
    <tr>
      <th scope="col">Memory Region </th>
      <th scope="col">Used Size</th>
      <th scope="col">Region Size</th>
	  <th scope="col">%age Used</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th scope="row">FLASH:</th>
      <td>40540 B</td>
      <td> 2 MB</td>
	  <td>1.93%</td>
    </tr>
    <tr>
	<th scope="row">RAM:</th>
      <td>6920 B </td>
	  <td>256 KB</td>
	  <td>2.64%</td>
    </tr>
	<tr>
	<th scope="row">SCRATCH_X:</th>
      <td>0 GB</td>
	  <td>4 KB</td>
	  <td>0.00%</td>
    </tr>
	<tr>
	<th scope="row">SCRATCH_Y:</th>
      <td>0 GB</td>
	  <td>4 KB</td>
	  <td>0.00%</td>
    </tr>
  </tbody>
</table>

### Polling + IRQ in C
<table>
  <thead>
    <tr>
      <th scope="col">Memory Region </th>
      <th scope="col">Used Size</th>
      <th scope="col">Region Size</th>
	  <th scope="col">%age Used</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th scope="row">FLASH:</th>
      <td>40788 B</td>
      <td> 2 MB</td>
	  <td>1.94%</td>
    </tr>
    <tr>
	<th scope="row">RAM:</th>
      <td>6924 B</td>
	  <td>256 KB</td>
	  <td>2.64%</td>
    </tr>
	<tr>
	<th scope="row">SCRATCH_X:</th>
      <td>0 GB</td>
	  <td>4 KB</td>
	  <td>0.00%</td>
    </tr>
	<tr>
	<th scope="row">SCRATCH_Y:</th>
      <td>0 GB</td>
	  <td>4 KB</td>
	  <td>0.00%</td>
    </tr>
  </tbody>
</table>

### Polling in MicroPython

To get the memory usage information with microPython it is needed to use the next code lines: 
```python
import micropython
micropython.mem_info()
```

>GC: total: 191872, used: 22096, free: 169776

Which means a use of 11.5% of the total memory.

### Polling in Arduino
Just uploading the sketch from Arduino IDE to Raspberry Pi Pico, we get the next information:

```
Global variables use 43172 bytes (15%) of dynamic memory, leaving 227164 bytes for local variables. Maximum is 270336 bytes.
```