"""
 - ``Author``:  MST_CDA
 - ``Date``:  2024-04-14
 - ``Version``:  1.0
 - ``file``: main.py
 
This proyect implements an digital signal generator.

In this practice, we will develop a Digital Signal Generator (DSG) device. 
The DSG device generates 4 different waveforms: sine, triangular, sawtooth, and square. 
The user can select the type of waveform generated by the DSG using a push button. 
Each time the button is pressed, the system switches from one waveform to the next sequentially. 
The amplitude, DC level (offset), and signal frequency are entered using a 4x4 matrix keypad. 
To enter the amplitude, the user will press the A key followed by the desired voltage value in 
millivolts and the D key to finalize. Similarly, to enter the DC level, the user will press 
the B key followed by the desired DC voltage value in millivolts and the D key to finalize. 
Finally, to enter the frequency, the user must press the C key followed by the frequency 
value in Hertz and the D key to finalize. The current values of Amplitude, DC Level, and 
Frequency along with the current waveform will be printed every second via the serial or USB 
interface to a terminal tool. 

The Amplitude should be adjustable between 100mV and 2500mV, the DC Level between 50mV and 1250mV. 
The frequency should be adjustable between 1 Hz and 12000000 Hz. 
Therefore, the max range for the value of the signal is: -2450mV to 3750mV.

By default, the DSG device starts generating a sinusoidal signal with an amplitude of 1000 mV, 
DC Level of 500mV, and frequency of 10Hz. The generated signal and its characteristics 
should be able to be verified by a measuring instrument, multimeter, or oscilloscope.

   The DSG device should be implemented using the following hardware components:
   - RPPS (Raspberry Pi Pico System) board.
   - 4x4 matrix keypad.
   - Digital-to-Analog Converter (DAC0808).
   - Operational Amplifier (LM358).
   - LED

NOTE: Using Pin.value(), it must take into account that: 
    - If is given a parameter and it is Pin.OUT: it sets the pin to what is given.
    - If no parameter is given and it is Pin.IN: it returns the current value of the pin.
    To other cases, its behavior is not defined.

"""

# Some auxiliary functions
def checkNumer(number: int):
    return (number >= 0 & number <= 9)

def checkLetter(letter: int):
    return (letter >= 0x0A & letter <= 0x0C)

def checkFreq(freq: int):
    return (freq >= 1 & freq <= 12000000)

def checkAmp(amp: int):
    return (amp >= 100 & amp <= 2500)

def checkOffset(offset: int):
    return (offset >= 50 & offset <= 1250)

# ----------------------------------------------------------------------------
# ----------------------------- TIME BASE ------------------------------------
# ----------------------------------------------------------------------------

from utime import ticks_us

class Time_base:
    """
    Class for time_base.
    It is the key for the polling strategy.
    """

    next: int
    delta: int
    en: bool

    def __init__(self, us: int, en: bool):
        """
        Constructor for time_base.

        Parameters:
        - ``us`` Time in microseconds.
        - ``en`` Enable the timer.
        """
        self.next = ticks_us() + us
        self.delta = us
        self.en = en
    
    def check(self):
        """
        Check if the timer has expired.

        Returns:
        - ``bool`` True if the timer has expired.
        """
        return (self.en and ticks_us() >= self.next)
    
    def update(self):
        """
        Update the next time in microseconds.
        """
        self.next = ticks_us() + self.delta

    def set_next(self):
        """
        Set the next time in microseconds.
        """
        self.next = self.next + self.delta

    def enable(self):
        """
        Enable the timer.
        """
        self.en = True

    def disable(self):
        """
        Disable the timer.
        """
        self.en = False

    def set_delta(self, us: int):
        """
        Set the time in microseconds.

        Parameters:
        - ``us`` Time in microseconds.
        """
        self.delta = us

# ----------------------------------------------------------------------------
# ----------------------------- BUTTON ---------------------------------------
# ----------------------------------------------------------------------------

from machine import Pin

class Button:
    """
    Class to process the button.

    It is used as a base class for the keypad -> Herency
    """
    gpioPin: Pin        # The gpio for the button
    en: bool            # Enable the button processing

    dbnc: bool          # Flag that indicates that debouncer is active
    dzero: bool         # Flag for double zero
    nkey: bool          # Flag that indicates that a key was pressed
    tb_dbnce: Time_base # Periocic time base used to implement the key debouncer

    def __init__(self, gpio: int, dbnc_time: int, en: bool):
        """
        Constructor for Button.

        Parameters:
        - ``gpio`` The gpio number for the button.
        - ``dbnc_time`` Time in us for the debouncer.
        - ``en`` Enable button processing.
        """
        # Initialize the button variables
        self.en = en
        self.dbnc = False
        self.dzero = False
        self.nkey = False

        self.gpioPin = Pin(gpio, Pin.IN, Pin.PULL_UP)
        self.tb_dbnce = Time_base(dbnc_time, False)

    def set_zflag(self):
        """
        Set the double zero flag.
        """
        self.dzero = True

    def clear_zflag(self):
        """
        Clear the double zero flag.
        """
        self.dzero = False

    def is_2nd_zero(self) -> bool:
        """
        This method returns true if a first zero was detected on keypad columns
        """
        return self.dzero



# ----------------------------------------------------------------------------
# ----------------------------- KEYPAD ---------------------------------------
# ----------------------------------------------------------------------------


class KeyPad:
    cols: int           # store the columns state
    cnt: int            # counter to generate row sequence
    seq: int            # store the current sequence state
    ckey: int           # captured key with position coding
    dkey: int           # captured key with decimal coding
    rlsb: int           # The rows LSB position for keypad rows, the four gpios for rows must be consecutives starting in position rlsb
    clsb: int           # The cols LSB position for keypad cols, the four gpios for cols must be consecutives starting in position clsb
    en: bool            # Enable keypad processing
    dzero: bool         # Flag for double zero
    nkey: bool          # Flag that indicates that a key was pressed
    dbnc: bool          # Flag that indicates that debouncer is active      
    tb_seq: Time_base           # Periodic time base used to generate row sequence
    tb_dbnce: Time_base         # Periocic time base used to implement the key debouncer
    history = []     # The last 10 pressed keys
    gpioC = []        # The four gpios for cols
    gpioR = []        # The four gpios for rows

    def __init__(self, rlsb: int, clsb: int, dbnc_time: int, en: bool):
        """
        Constructor for KeyPad.

        Parameters:
        - ``rlsb`` The rows LSB position for keypad rows, the four gpios for rows must be consecutives.
        - ``clsb`` The cols LSB position for keypad cols, the four gpios for cols must be consecutives.
        - ``dbnc_time`` Time in us for the debouncer.
        - ``en`` Enable keypad processing.
        """
        # Initialize history buffer
        for i in range(10):
            self.history.append(int(0xff))
        # Initialize the keypad variables
        self.cols = 0
        self.cnt = 0x0
        self.seq = 0x8
        self.ckey = 0
        self.dkey = 0x1F
        self.rlsb = rlsb
        self.clsb = clsb
        self.en = en
        self.dzero = False
        self.nkey = False
        self.dbnc = False
        # Initialize time bases
        self.tb_seq = Time_base(2000, True)
        self.tb_dbnce = Time_base(dbnc_time, False)

        # Initialize the gpios
        for i in range(4):
            self.gpioR.append(Pin(self.rlsb + i, Pin.OUT))
            self.gpioC.append(Pin(self.clsb + i, Pin.IN, Pin.PULL_UP))


    def captureKey(self):
        """
        Capture the key pressed.
        Before this metod, it must be called the captureCols method.
        """
        # Key processing
        self.ckey = (self.cols << 4) | self.seq
        self.decode()
        # Store the key in the history buffer
        for i in range(9):
            self.history[9 - i] = self.history[9 - i - 1]
        self.history[0] = self.dkey
        # Set the new key flag
        self.nkey = True

    def captureCols(self):
        """
        Capture the columns state.
        """
        self.cols = 0
        for i in range(4):
            self.cols |= (self.gpioC[i].value() << i)
    
    def decode(self):
        """
        Decode the key pressed.
        """
        if self.ckey == 0x77:
            self.dkey = 0x01
        elif self.ckey == 0xb7:
            self.dkey = 0x02
        elif self.ckey == 0xd7:
            self.dkey = 0x03
        elif self.ckey == 0xe7:
            self.dkey = 0x0A
        elif self.ckey == 0x7b:
            self.dkey = 0x04
        elif self.ckey ==0xbb:
            self.dkey = 0x05
        elif self.ckey == 0xdb:
            self.dkey = 0x06
        elif self.ckey == 0xeb:
            self.dkey = 0x0B
        elif self.ckey == 0x7d:
            self.dkey = 0x07
        elif self.ckey == 0xbd:
            self.dkey = 0x08
        elif self.ckey == 0xdd:
            self.dkey = 0x09
        elif self.ckey == 0xed:
            self.dkey = 0x0C
        elif self.ckey == 0x7e:
            self.dkey = 0x0E
        elif self.ckey == 0xbe:
            self.dkey = 0x00
        elif self.ckey == 0xde:
            self.dkey = 0x0F
        elif self.ckey == 0xee:
            self.dkey = 0x0D

    def gen_seq(self):
        """
        Generate the row sequence.
        """
        if not self.en:
            return
        
        self.cnt = (self.cnt + 1)%4
        # self.seq = (1 << self.cnt) & 0x0000000F
        # Reverse the sequence
        if self.cnt == 0x0:
            self.seq = 0b1110
        elif self.cnt == 0x1:
            self.seq = 0b1101
        elif self.cnt == 0x2:
            self.seq = 0b1011
        elif self.cnt == 0x3:
            self.seq = 0b0111

        for i in range(4):
            self.gpioR[i].value((self.seq >> i) & 0x1)


    def get_key(self) -> int:
        """
        Get the last key pressed.
        """
        return self.dkey
    
    def set_zflag(self):
        """
        Set the double zero flag.
        """
        self.dzero = True

    def clear_zflag(self):
        """
        Clear the double zero flag.
        """
        self.dzero = False

    def is_2nd_zero(self) -> bool:
        """
        This method returns true if a first zero was detected on keypad columns
        """
        return self.dzero

# ----------------------------------------------------------------------------
# ----------------------------- SIGNAL GENERATOR -----------------------------
# ----------------------------------------------------------------------------


from math import sin, pi
from utime import ticks_us

S_TO_US = 1000000
US_TO_S = 0.000001
SAMPLE = 16
DAC_BIAS = 500

class Signal:
    ss: int             # Signal State: 0: Sinusoidal, 1: Triangular, 2: Sawtooth, 3: Square
    en: bool            # Enable the signal generator
    freq: int           # Frequency in Hz
    amp: int            # Amplitude in mV
    offset: int         # Offset in mV
    value: int          # Current value in mV
    arrayV = [] # Array of values for the signal
    cnt: int            # Counter for the signal
    tb_gen: Time_base   # Time base for the signal generator

    def __init__(self, freq: int, amp: int, offset: int, en: bool):
        """
        Constructor for signal_generator.

        Parameters:
        - ``freq`` Frequency in Hz.
        - ``amp`` Amplitude in mV.
        - ``offset`` Offset in mV.
        - ``en`` Enable the signal generator.
        """
        self.ss = 0
        self.en = en
        self.freq = freq
        self.amp = amp
        self.offset = offset
        self.value = 0
        self.cnt = 0
        self.tb_gen = Time_base(S_TO_US // (SAMPLE*freq), True)
        for i in range(SAMPLE):
            self.arrayV.append(0)

    def gen_sin(self, t: int):
        """
        Generate a sinusoidal signal.
        """
        self.value = int(self.offset + self.amp*sin((2*pi*t)/SAMPLE))

    def gen_tri(self, t: int):
        """
        Generate a triangular signal.
        """
        if (t <= SAMPLE/2):
            self.value = int(self.offset + (4*self.amp*t)/SAMPLE - self.amp)
    
        else:
            self.value = int(self.offset - (4*self.amp*t)/SAMPLE + 3*self.amp)

    def gen_saw(self, t: int):
        """
        Generate a sawtooth signal.
        """
        self.value = int(self.offset + (2*self.amp*t)/SAMPLE - self.amp)

    def gen_sqr(self, t: int):
        """
        Generate a square signal.
        """
        if (t <= SAMPLE/2):
            self.value = int(self.offset + self.amp)
    
        else:
            self.value = int(self.offset - self.amp)

    def calculate(self):
        """
        Update the value of the signal generator according to the signal state.
        """

        if not self.en:
            return

        if self.ss == 0:
            for i in range(SAMPLE):
                self.gen_sin(i + 1)
                self.arrayV[i] = self.value + DAC_BIAS # Offset of the DAC
        elif self.ss == 1:
            for i in range(SAMPLE):
                self.gen_tri(i + 1)
                self.arrayV[i] = self.value + DAC_BIAS # Offset of the DAC
        elif self.ss == 2:
            for i in range(SAMPLE):
                self.gen_saw(i + 1)
                self.arrayV[i] = self.value + DAC_BIAS # Offset of the DAC
        elif self.ss == 3:
            for i in range(SAMPLE):
                self.gen_sqr(i + 1)
                self.arrayV[i] = self.value + DAC_BIAS # Offset of the DAC
        

    def get_value(self) -> int:
        """
        Get the current value of the signal generator.

        Returns:
        - ``value`` Current value in mV.
        """
        return self.value

    def set_ss(self, ss: int):
        """
        Set the signal state.

        Parameters:
        - ``ss`` Signal State: 0: Sinusoidal, 1: Triangular, 2: Sawtooth, 3: Square
        """
        self.ss = ss

    def set_freq(self, freq: int):
        """
        Set the frequency in Hz.

        Parameters:
        - ``freq`` Frequency in Hz.
        """
        self.freq = freq
        self.tb_gen.set_delta(S_TO_US // (SAMPLE*freq))

    def set_amp(self, amp: int):
        """
        Set the amplitude in mV.

        Parameters:
        - ``amp`` Amplitude in mV.
        """
        self.amp = amp

    def set_offset(self, offset: int):
        """
        Set the offset in mV.

        Parameters:
        - ``offset`` Offset in mV.
        """
        self.offset = offset

# ----------------------------------------------------------------------------
# ----------------------------- DAC ------------------------------------------
# ----------------------------------------------------------------------------

RESOLUTION = 255        # 8 bits
DAC_RANGE = 9400        # 0 to 9.3V

class DAC:
    """
    Class to impress the DAC (8bits).
    """
    en: bool                # Enable the DAC processing
    gpioD = []   # The eight gpios for the DAC
    lsb: int                # The LSB position for the DAC, the eight gpios must be consecutives.
    digit_v: int            # The digit value for the DAC

    def __init__(self, lsb: int, en: bool):
        """
        Constructor for DAC.

        Parameters:
        - ``lsb`` The LSB position for the DAC, the eight gpios must be consecutives.
        - ``en`` Enable DAC processing.
        """
        # Initialize the DAC variables
        self.en = en
        self.lsb = lsb
        # Initialize the DAC gpios
        for i in range(8):
            self.gpioD.append(Pin(lsb + i, Pin.OUT)) 

    def set_dac(self, value: int):
        """
        Set the DAC value.

        Parameters:
        - ``value`` The value to be set in the DAC.
        """
        if not self.en:
            return

        self.digit_v = (value + 5000)*RESOLUTION//DAC_RANGE
        for i in range(8):
            self.gpioD[i].value(self.digit_v % 2)
            self.digit_v = self.digit_v // 2


# ----------------------------------------------------------------------------
# ----------------------------- LED ------------------------------------------
# ----------------------------------------------------------------------------

class Led:
    """
    Class to process a led.
    """
    gpioPin: Pin       # The gpio for the led
    on: bool           # Its principal aim is to make a toggle

    def __init__(self, gpio: int, on: bool):
        """
        Constructor for Led.

        Parameters:
        - ``gpio`` The gpio number for the led.
        - ``state`` True to turn on the led, False to turn off the led.
        """
        # Initialize the led variables
        self.on = on
        self.gpioPin = Pin(gpio, Pin.OUT)
        self.gpioPin.value(self.on)

    def set(self):
        """
        Turn on the led.
        """
        self.gpioPin.high()
        self.on = True

    def clear(self):
        """
        Turn off the led.
        """
        self.gpioPin.low()
        self.on = False

    def toggle(self):
        """
        Toggle the led.
        """
        self.gpioPin.value(not self.on)
        self.on = not self.on


# Import the modules
# from time_base import Time_base
# from gpio_button import Button
# from keypad_polling import KeyPad
# from signal_generator import Signal, SAMPLE
# from dac import DAC
# from gpio_led import Led

# Initialize the objects
my_signal = Signal(1, 1000, 500, True)
my_signal.calculate()
my_dac = DAC(10, True)
my_led = Led(18, True)
my_keypad = KeyPad(2, 6, 100000, True)
my_button = Button(0, 100000, True)
tb_print = Time_base(1000000, True)

# Auxiliar variables
in_state: int = 0x0 # 0: Nothing, 1: Amp, 2: Offset, 3: Freq
key_cnt: int = 0x0
param: int = 0x0

# Main loop
while True:
    # Get the keypad columns
    my_keypad.captureCols()
    # Process the keypad
    if ((my_keypad.cols != 0x0f) & (not my_keypad.dbnc)):
        my_keypad.tb_seq.disable()
        my_keypad.captureKey() # Capture the key
        my_keypad.tb_dbnce.update()
        my_keypad.tb_dbnce.enable()
        my_keypad.set_zflag()
        my_keypad.dbnc = True
    
    if (my_keypad.tb_seq.check()):
        my_keypad.tb_seq.set_next()
        my_keypad.gen_seq()

    if (my_keypad.tb_dbnce.check()):
        my_keypad.tb_dbnce.set_next()
        if (my_keypad.is_2nd_zero()):
            if (my_keypad.cols == 0x0f):
                my_keypad.tb_seq.update()
                my_keypad.tb_seq.enable()
                my_keypad.tb_dbnce.disable()
                my_keypad.dbnc = False
            else: 
                my_keypad.clear_zflag()
        else:
            if (my_keypad.cols == 0x0f):
                my_keypad.set_zflag()
    
    # Process the button (low active)
    boolButton: bool = bool(my_button.gpioPin.value())
    if ((not boolButton) & (not my_button.dbnc)):
        my_button.nkey = True # A key was pressed
        my_button.tb_dbnce.update()
        my_button.tb_dbnce.enable()
        my_button.dbnc = True
    
    if (my_button.tb_dbnce.check()):
        my_button.tb_dbnce.set_next()
        if (my_button.is_2nd_zero()):   
            if (boolButton):
                my_signal.set_ss((my_signal.ss + 1) % 4)
                my_signal.calculate()
                my_button.tb_dbnce.disable()
                my_button.dbnc = False
                print("The button was proccessed")
            else: 
                my_button.clear_zflag()
        else:
            if (boolButton):
                my_button.set_zflag()
    
    
    # Process the signal
    if (my_signal.tb_gen.check()):
        my_signal.tb_gen.set_next() 
        my_dac.set_dac(my_signal.arrayV[my_signal.cnt])
        my_signal.cnt = (my_signal.cnt + 1) % SAMPLE

    # Printing the signal
    if (tb_print.check()):
        tb_print.set_next()
        if (my_signal.ss == 0):
            print("Sinusoidal: ")
        elif (my_signal.ss == 1):
            print("Triangular: ")
        elif (my_signal.ss == 2):
            print("Sawtooth: ")
        elif (my_signal.ss == 3):
            print("Square: ")

        print("Amp: ", my_signal.amp, "mV", "Offset: ", my_signal.offset, "mV", "Freq: ", my_signal.freq, "Hz")
        print("\n")

    # Process entering parameters
    if (my_keypad.nkey & (not my_keypad.dbnc)):
        # To accept a number, in_param_state must be different of 0
        if (checkNumer(my_keypad.dkey) & in_state):
            print("Number \n")
            param = param*10 + my_keypad.dkey
            key_cnt += 1
        # To accept a letter except 0xD, in_param_state must be 0
        elif (checkLetter(my_keypad.dkey) & (not in_state)):
            print("Letter \n")
            my_led.set()
            if (my_keypad.dkey == 0x0A):
                in_state = 1
            elif (my_keypad.dkey == 0x0B):
                in_state = 2
            elif (my_keypad.dkey == 0x0C):
                in_state = 3
        # To accept a 0x0D, in_param_state must be different of 0
        elif (my_keypad.dkey == 0x0D & in_state):
            print("D \n")
            my_led.clear()
            if (in_state == 1):
                if (checkAmp(param)):
                    my_signal.set_amp(param)
                else:
                    print("Invalid amplitude value")
            elif (in_state == 2):
                if (checkOffset(param)):
                    my_signal.set_offset(param)
                else:
                    print("Invalid offset value")
            elif (in_state == 3):
                if (checkFreq(param)):
                    my_signal.set_freq(param)
                else:
                    print("Invalid frequency value")
            my_signal.calculate()
            in_state = 0
            param = 0
            key_cnt = 0
        print("State: ", in_state)
        print("\n")
        # Aknowledge the key
        my_keypad.nkey = False

# End of the program
            
